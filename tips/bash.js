[
  {
    "Author": "stackoverflow",
    "url": "https://stackoverflow.com",
    "format": "html",
    "tips": [
      {
        "title": "Getting the source directory of a Bash script from within",
        "body": "<pre><code>DIR=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" &amp;&amp; pwd )\"\n</code></pre>\n\n<p>is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.</p>\n\n<p>It will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:</p>\n\n<pre><code>SOURCE=\"${BASH_SOURCE[0]}\"\nwhile [ -h \"$SOURCE\" ]; do # resolve $SOURCE until the file is no longer a symlink\n  DIR=\"$( cd -P \"$( dirname \"$SOURCE\" )\" &amp;&amp; pwd )\"\n  SOURCE=\"$(readlink \"$SOURCE\")\"\n  [[ $SOURCE != /* ]] &amp;&amp; SOURCE=\"$DIR/$SOURCE\" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located\ndone\nDIR=\"$( cd -P \"$( dirname \"$SOURCE\" )\" &amp;&amp; pwd )\"\n</code></pre>\n\n<p>This last one will work with any combination of aliases, <code>source</code>, <code>bash -c</code>, symlinks, etc.</p>\n\n<p>Beware: if you <code>cd</code> to a different directory before running this snippet, the result may be incorrect! Also, watch out for <a href=\"http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/\" rel=\"noreferrer\"><code>$CDPATH</code> gotchas</a>.</p>\n\n<p>To understand how it works, try running this more verbose form:</p>\n\n<pre><code>#!/bin/bash\n\nSOURCE=\"${BASH_SOURCE[0]}\"\nwhile [ -h \"$SOURCE\" ]; do # resolve $SOURCE until the file is no longer a symlink\n  TARGET=\"$(readlink \"$SOURCE\")\"\n  if [[ $TARGET == /* ]]; then\n    echo \"SOURCE '$SOURCE' is an absolute symlink to '$TARGET'\"\n    SOURCE=\"$TARGET\"\n  else\n    DIR=\"$( dirname \"$SOURCE\" )\"\n    echo \"SOURCE '$SOURCE' is a relative symlink to '$TARGET' (relative to '$DIR')\"\n    SOURCE=\"$DIR/$TARGET\" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located\n  fi\ndone\necho \"SOURCE is '$SOURCE'\"\nRDIR=\"$( dirname \"$SOURCE\" )\"\nDIR=\"$( cd -P \"$( dirname \"$SOURCE\" )\" &amp;&amp; pwd )\"\nif [ \"$DIR\" != \"$RDIR\" ]; then\n  echo \"DIR '$RDIR' resolves to '$DIR'\"\nfi\necho \"DIR is '$DIR'\"\n</code></pre>\n\n<p>And it will print something like:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>SOURCE './scriptdir.sh' is a relative symlink to 'sym2/scriptdir.sh' (relative to '.')\nSOURCE is './sym2/scriptdir.sh'\nDIR './sym2' resolves to '/home/ubuntu/dotfiles/fo fo/real/real1/real2'\nDIR is '/home/ubuntu/dotfiles/fo fo/real/real1/real2'\n</code></pre>\n",
        "source": "so",
        "questionId": 59895
      },
      {
        "title": "How do I tell if a regular file does not exist in Bash?",
        "body": "<p>The <a href=\"http://man7.org/linux/man-pages/man1/test.1.html\" rel=\"noreferrer\">test</a> command (<code>[</code> here) has a \"not\" logical operator which is the exclamation point (similar to many other languages). Try this:</p>\n\n<pre><code>if [ ! -f /tmp/foo.txt ]; then\n    echo \"File not found!\"\nfi\n</code></pre>\n",
        "source": "so",
        "questionId": 638975
      },
      {
        "title": "How to concatenate string variables in Bash",
        "body": "<pre><code>foo=\"Hello\"\nfoo=\"$foo World\"\necho $foo\n&gt; Hello World\n</code></pre>\n\n<p>In general to concatenate two variables you can just write them one after another:</p>\n\n<pre><code>a='hello'\nb='world'\nc=$a$b\necho $c\n&gt; helloworld\n</code></pre>\n",
        "source": "so",
        "questionId": 4181703
      },
      {
        "title": "In the shell, what does &quot; 2&gt;&amp;1 &quot; mean?",
        "body": "<p>File descriptor 1 is the standard output (stdout).<br>\nFile descriptor 2 is the standard error (stderr).</p>\n\n<p>Here is one way to remember this construct (although it is not entirely accurate): at first, <code>2&gt;1</code> may look like a good way to redirect stderr to stdout. However, it will actually be interpreted as \"redirect stderr to a file named <code>1</code>\". <code>&amp;</code> indicates that what follows is a file descriptor and not a filename. So the construct becomes: <code>2&gt;&amp;1</code>.</p>\n",
        "source": "so",
        "questionId": 818255
      },
      {
        "title": "String contains in Bash",
        "body": "<p>You can use <a href=\"https://stackoverflow.com/a/229585/3755692\">Marcus's answer (* wildcards)</a> outside a case statement, too, if you use double brackets:</p>\n\n<pre><code>string='My long string'\nif [[ $string = *\"My long\"* ]]; then\n  echo \"It's there!\"\nfi\n</code></pre>\n\n<p>Note that spaces in the needle string need to be placed between double quotes, and the <code>*</code> wildcards should be outside.</p>\n",
        "source": "so",
        "questionId": 229551
      },
      {
        "title": "Extract filename and extension in Bash",
        "body": "<p>First, get file name without the path:</p>\n\n<pre><code>filename=$(basename -- \"$fullfile\")\nextension=\"${filename##*.}\"\nfilename=\"${filename%.*}\"\n</code></pre>\n\n<p>Alternatively, you can focus on the last '/' of the path instead of the '.' which should work even if you have unpredictable file extensions:</p>\n\n<pre><code>filename=\"${fullfile##*/}\"\n</code></pre>\n",
        "source": "so",
        "questionId": 965053
      },
      {
        "title": "Check if a program exists from a Bash script",
        "body": "<h2>Answer</h2>\n\n<p>POSIX compatible:</p>\n\n<pre><code>command -v &lt;the_command&gt;\n</code></pre>\n\n<p>For <code>bash</code> specific environments:</p>\n\n<pre><code>hash &lt;the_command&gt; # For regular commands. Or...\ntype &lt;the_command&gt; # To check built-ins and keywords\n</code></pre>\n\n<h2>Explanation</h2>\n\n<p>Avoid <code>which</code>.  Not only is it an external process you're launching for doing very little (meaning builtins like <code>hash</code>, <code>type</code> or <code>command</code> are way cheaper), you can also rely on the builtins to actually do what you want, while the effects of external commands can easily vary from system to system.</p>\n\n<p>Why care?</p>\n\n<ul>\n<li>Many operating systems have a <code>which</code> that <strong>doesn't even set an exit status</strong>, meaning the <code>if which foo</code> won't even work there and will <strong>always</strong> report that <code>foo</code> exists, even if it doesn't (note that some POSIX shells appear to do this for <code>hash</code> too).</li>\n<li>Many operating systems make <code>which</code> do custom and evil stuff like change the output or even hook into the package manager.</li>\n</ul>\n\n<p>So, don't use <code>which</code>.  Instead use one of these:</p>\n\n<pre><code>$ command -v foo &gt;/dev/null 2&gt;&amp;1 || { echo &gt;&amp;2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\n$ type foo &gt;/dev/null 2&gt;&amp;1 || { echo &gt;&amp;2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\n$ hash foo 2&gt;/dev/null || { echo &gt;&amp;2 \"I require foo but it's not installed.  Aborting.\"; exit 1; }\n</code></pre>\n\n<p>(Minor side-note: some will suggest <code>2&gt;&amp;-</code> is the same <code>2&gt;/dev/null</code> but shorter – <em>this is untrue</em>.  <code>2&gt;&amp;-</code> closes FD 2 which causes an <strong>error</strong> in the program when it tries to write to stderr, which is very different from successfully writing to it and discarding the output (and dangerous!))</p>\n\n<p>If your hash bang is <code>/bin/sh</code> then you should care about what POSIX says.  <code>type</code> and <code>hash</code>'s exit codes aren't terribly well defined by POSIX, and <code>hash</code> is seen to exit successfully when the command doesn't exist (haven't seen this with <code>type</code> yet).  <code>command</code>'s exit status is well defined by POSIX, so that one is probably the safest to use.</p>\n\n<p>If your script uses <code>bash</code> though, POSIX rules don't really matter anymore and both <code>type</code> and <code>hash</code> become perfectly safe to use.  <code>type</code> now has a <code>-P</code> to search just the <code>PATH</code> and <code>hash</code> has the side-effect that the command's location will be hashed (for faster lookup next time you use it), which is usually a good thing since you probably check for its existence in order to actually use it.</p>\n\n<p>As a simple example, here's a function that runs <code>gdate</code> if it exists, otherwise <code>date</code>:</p>\n\n<pre><code>gnudate() {\n    if hash gdate 2&gt;/dev/null; then\n        gdate \"$@\"\n    else\n        date \"$@\"\n    fi\n}\n</code></pre>\n",
        "source": "so",
        "questionId": 592620
      },
      {
        "title": "Echo newline in Bash prints literal \\n",
        "body": "<p>You could use <code>printf</code> instead:</p>\n\n<pre><code>printf \"hello\\nworld\\n\"\n</code></pre>\n\n<p><code>printf</code> has more consistent behavior than <code>echo</code>. The behavior of <code>echo</code> varies greatly between different versions.</p>\n",
        "source": "so",
        "questionId": 8467424
      },
      {
        "title": "How do I split a string on a delimiter in Bash?",
        "body": "<p>You can set the <a href=\"http://en.wikipedia.org/wiki/Internal_field_separator\" rel=\"noreferrer\">internal field separator</a> (IFS) variable, and then let it parse into an array. When this happens in a command, then the assignment to <code>IFS</code> only takes place to that single command's environment (to <code>read</code> ). It then parses the input according to the <code>IFS</code> variable value into an array, which we can then iterate over.</p>\n\n<pre><code>IFS=';' read -ra ADDR &lt;&lt;&lt; \"$IN\"\nfor i in \"${ADDR[@]}\"; do\n    # process \"$i\"\ndone\n</code></pre>\n\n<p>It will parse one line of items separated by <code>;</code>, pushing it into an array. Stuff for processing whole of <code>$IN</code>, each time one line of input separated by <code>;</code>:</p>\n\n<pre><code> while IFS=';' read -ra ADDR; do\n      for i in \"${ADDR[@]}\"; do\n          # process \"$i\"\n      done\n done &lt;&lt;&lt; \"$IN\"\n</code></pre>\n",
        "source": "so",
        "questionId": 918886
      },
      {
        "title": "How do I parse command line arguments in Bash?",
        "body": "<h1>Preferred Method: Using straight bash without getopt[s]</h1>\n\n<p>I originally answered the question as the OP asked. This Q/A is getting a lot of attention, so I should also offer the non-magic way to do this. I'm going to expand upon <a href=\"https://stackoverflow.com/a/13359121/321973\">guneysus's answer</a> to fix the nasty sed and include <a href=\"https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash/13359121?noredirect=1#comment29656357_13359121\">Tobias Kienzler's suggestion</a>.</p>\n\n<p>Two of the most common ways to pass key value pair arguments are:</p>\n\n<h2>Straight Bash Space Separated</h2>\n\n<p>Usage     <code> ./myscript.sh -e conf -s /etc -l /usr/lib /etc/hosts </code></p>\n\n<pre><code>#!/bin/bash\n\nPOSITIONAL=()\nwhile [[ $# -gt 0 ]]\ndo\nkey=\"$1\"\n\ncase $key in\n    -e|--extension)\n    EXTENSION=\"$2\"\n    shift # past argument\n    shift # past value\n    ;;\n    -s|--searchpath)\n    SEARCHPATH=\"$2\"\n    shift # past argument\n    shift # past value\n    ;;\n    -l|--lib)\n    LIBPATH=\"$2\"\n    shift # past argument\n    shift # past value\n    ;;\n    --default)\n    DEFAULT=YES\n    shift # past argument\n    ;;\n    *)    # unknown option\n    POSITIONAL+=(\"$1\") # save it in an array for later\n    shift # past argument\n    ;;\nesac\ndone\nset -- \"${POSITIONAL[@]}\" # restore positional parameters\n\necho FILE EXTENSION  = \"${EXTENSION}\"\necho SEARCH PATH     = \"${SEARCHPATH}\"\necho LIBRARY PATH    = \"${LIBPATH}\"\necho DEFAULT         = \"${DEFAULT}\"\necho \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l)\nif [[ -n $1 ]]; then\n    echo \"Last line of file specified as non-opt/last argument:\"\n    tail -1 \"$1\"\nfi\n</code></pre>\n\n<h2>Straight Bash Equals Separated</h2>\n\n<p>Usage <code>./myscript.sh -e=conf -s=/etc -l=/usr/lib /etc/hosts</code></p>\n\n<pre><code>#!/bin/bash\n\nfor i in \"$@\"\ndo\ncase $i in\n    -e=*|--extension=*)\n    EXTENSION=\"${i#*=}\"\n    shift # past argument=value\n    ;;\n    -s=*|--searchpath=*)\n    SEARCHPATH=\"${i#*=}\"\n    shift # past argument=value\n    ;;\n    -l=*|--lib=*)\n    LIBPATH=\"${i#*=}\"\n    shift # past argument=value\n    ;;\n    --default)\n    DEFAULT=YES\n    shift # past argument with no value\n    ;;\n    *)\n          # unknown option\n    ;;\nesac\ndone\necho \"FILE EXTENSION  = ${EXTENSION}\"\necho \"SEARCH PATH     = ${SEARCHPATH}\"\necho \"LIBRARY PATH    = ${LIBPATH}\"\necho \"Number files in SEARCH PATH with EXTENSION:\" $(ls -1 \"${SEARCHPATH}\"/*.\"${EXTENSION}\" | wc -l)\nif [[ -n $1 ]]; then\n    echo \"Last line of file specified as non-opt/last argument:\"\n    tail -1 $1\nfi\n</code></pre>\n\n<p>To better understand <code>${i#*=}</code> search for \"Substring Removal\" in <a href=\"http://tldp.org/LDP/abs/html/string-manipulation.html\" rel=\"noreferrer\">this guide</a>. It is functionally equivalent to <code>`sed 's/[^=]*=//' &lt;&lt;&lt; \"$i\"`</code> which calls a needless subprocess or <code>`echo \"$i\" | sed 's/[^=]*=//'`</code> which calls <em>two</em> needless subprocesses. </p>\n\n<h1>Using getopt[s]</h1>\n\n<p>from: <a href=\"http://mywiki.wooledge.org/BashFAQ/035#getopts\" rel=\"noreferrer\">http://mywiki.wooledge.org/BashFAQ/035#getopts</a></p>\n\n<p><strong>Never use getopt(1).</strong> <code>getopt</code> cannot handle empty arguments strings, or arguments with embedded whitespace. Please forget that it ever existed.</p>\n\n<p>The POSIX shell (and others) offer <code>getopts</code> which is safe to use instead. Here is a simplistic <code>getopts</code> example:</p>\n\n<pre><code>#!/bin/sh\n\n# A POSIX variable\nOPTIND=1         # Reset in case getopts has been used previously in the shell.\n\n# Initialize our own variables:\noutput_file=\"\"\nverbose=0\n\nwhile getopts \"h?vf:\" opt; do\n    case \"$opt\" in\n    h|\\?)\n        show_help\n        exit 0\n        ;;\n    v)  verbose=1\n        ;;\n    f)  output_file=$OPTARG\n        ;;\n    esac\ndone\n\nshift $((OPTIND-1))\n\n[ \"$1\" = \"--\" ] &amp;&amp; shift\n\necho \"verbose=$verbose, output_file='$output_file', Leftovers: $@\"\n\n# End of file\n</code></pre>\n\n<p>The advantages of <code>getopts</code> are:</p>\n\n<ol>\n<li>It's portable, and will work in e.g. dash.  </li>\n<li>It can handle things like <code>-vf filename</code> in the expected Unix way, automatically.</li>\n</ol>\n\n<p>The disadvantage of <code>getopts</code> is that it can only handle short options (<code>-h</code>, not <code>--help</code>) without trickery.</p>\n\n<p>There is a <a href=\"http://wiki.bash-hackers.org/howto/getopts_tutorial\" rel=\"noreferrer\">getopts tutorial</a> which explains what all of the syntax and variables mean.  In bash, there is also <code>help getopts</code>, which might be informative.</p>\n",
        "source": "so",
        "questionId": 192249
      },
      {
        "title": "How to count all the lines of code in a directory recursively?",
        "body": "<p><strong>Try:</strong></p>\n\n<pre><code>find . -name '*.php' | xargs wc -l\n</code></pre>\n\n<p><strong><a href=\"http://www.dwheeler.com/sloccount/\" rel=\"noreferrer\">The SLOCCount tool</a></strong> may help as well.</p>\n\n<p>It'll give an accurate source lines of code count for whatever\nhierarchy you point it at, as well as some additional stats.</p>\n",
        "source": "so",
        "questionId": 1358540
      },
      {
        "title": "How do I reload .bashrc without logging out and back in?",
        "body": "<p>You just have to enter the command:</p>\n\n<pre><code>source ~/.bashrc\n</code></pre>\n\n<p>or you can use the shorter version of the command:</p>\n\n<pre><code>. ~/.bashrc\n</code></pre>\n",
        "source": "so",
        "questionId": 2518127
      },
      {
        "title": "How can I redirect and append both stdout and stderr to a file with Bash?",
        "body": "<pre><code>cmd &gt;&gt;file.txt 2&gt;&amp;1\n</code></pre>\n\n<p>Bash executes the redirects from left to right as follows:</p>\n\n<ol>\n<li><code>&gt;&gt;file.txt</code>: Open <code>file.txt</code> in append mode and redirect <code>stdout</code> there.</li>\n<li><code>2&gt;&amp;1</code>: Redirect <code>stderr</code> to <em>\"where <code>stdout</code> is currently going\"</em>. In this case, that is a file opened in append mode. In other words, the <code>&amp;1</code> reuses the file descriptor which <code>stdout</code> currently uses.</li>\n</ol>\n",
        "source": "so",
        "questionId": 876239
      },
      {
        "title": "How do I prompt for Yes/No/Cancel input in a Linux shell script?",
        "body": "<p>The simplest and most widely available method to get user input at a shell prompt is the <a href=\"http://www.gnu.org/software/bash/manual/bashref.html#index-read\" rel=\"noreferrer\"><code>read</code></a> command. The best way to illustrate its use is a simple demonstration:</p>\n\n<pre><code>while true; do\n    read -p \"Do you wish to install this program?\" yn\n    case $yn in\n        [Yy]* ) make install; break;;\n        [Nn]* ) exit;;\n        * ) echo \"Please answer yes or no.\";;\n    esac\ndone\n</code></pre>\n\n<p>Another method, pointed out by Steven Huwig, is Bash's <a href=\"http://www.gnu.org/software/bash/manual/bashref.html#index-select\" rel=\"noreferrer\"><code>select</code></a> command. Here is the same example using <code>select</code>:</p>\n\n<pre><code>echo \"Do you wish to install this program?\"\nselect yn in \"Yes\" \"No\"; do\n    case $yn in\n        Yes ) make install; break;;\n        No ) exit;;\n    esac\ndone\n</code></pre>\n\n<p>With <code>select</code> you don't need to sanitize the input &ndash; it displays the available choices, and you type a number corresponding to your choice. It also loops automatically, so there's no need for a <code>while true</code> loop to retry if they give invalid input.</p>\n\n<p>Also, please check out the <a href=\"https://stackoverflow.com/a/27875395/9084\">excellent answer</a> by F. Hauri.</p>\n",
        "source": "so",
        "questionId": 226703
      },
      {
        "title": "How to change the output color of echo in Linux",
        "body": "<p>You can use these <a href=\"https://en.wikipedia.org/wiki/ANSI_escape_code\" rel=\"noreferrer\">ANSI escape codes</a>:</p>\n\n<pre><code>Black        0;30     Dark Gray     1;30\nRed          0;31     Light Red     1;31\nGreen        0;32     Light Green   1;32\nBrown/Orange 0;33     Yellow        1;33\nBlue         0;34     Light Blue    1;34\nPurple       0;35     Light Purple  1;35\nCyan         0;36     Light Cyan    1;36\nLight Gray   0;37     White         1;37\n</code></pre>\n\n<p>And then use them like this in your script:</p>\n\n<pre><code>#    .---------- constant part!\n#    vvvv vvvv-- the code from above\nRED='\\033[0;31m'\nNC='\\033[0m' # No Color\nprintf \"I ${RED}love${NC} Stack Overflow\\n\"\n</code></pre>\n\n<p>which prints <code>love</code> in red.</p>\n\n<p>From @james-lim's comment, if you are using the <code>echo</code> command, be sure to use the -e flag to allow backslash escapes.</p>\n\n<pre><code># Continued from above example\necho -e \"I ${RED}love${NC} Stack Overflow\"\n</code></pre>\n\n<p>(don't add <code>\"\\n\"</code> when using echo unless you want to add additional empty line)</p>\n",
        "source": "so",
        "questionId": 5947742
      },
      {
        "title": "How to set a variable to the output from a command in Bash?",
        "body": "<p>In addition to the backticks, you can use <code>$()</code>, which I find easier to read, and allows for nesting.</p>\n\n<pre><code>OUTPUT=\"$(ls -1)\"\necho \"${OUTPUT}\"\n</code></pre>\n\n<p>Quoting (<code>\"</code>) does matter to preserve multi-line values.</p>\n",
        "source": "so",
        "questionId": 4651437
      },
      {
        "title": "How to check if a variable is set in Bash?",
        "body": "<h2>The right way</h2>\n\n<pre><code>if [ -z ${var+x} ]; then echo \"var is unset\"; else echo \"var is set to '$var'\"; fi\n</code></pre>\n\n<p>where <code>${var+x}</code> is a <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02\" rel=\"noreferrer\">parameter expansion</a> which evaluates to nothing if <code>var</code> is unset, and substitutes the string <code>x</code> otherwise.</p>\n\n<h3>Quotes Digression</h3>\n\n<p>Quotes can be omitted (so we can say <code>${var+x}</code> instead of <code>\"${var+x}\"</code>) because this syntax &amp; usage guarantees this will only expand to something that does not require quotes (since it either expands to <code>x</code> (which contains no word breaks so it needs no quotes), or to nothing (which results in <code>[ -z  ]</code>, which conveniently evaluates to the same value (true) that <code>[ -z \"\" ]</code> does as well)).</p>\n\n<p>However, while quotes can be safely omitted, and it was not immediately obvious to all (it wasn't even apparent to <a href=\"https://stackoverflow.com/users/2255628/destiny-architect\">the first author of this quotes explanation</a> who is also a major Bash coder), it would sometimes be better to write the solution with quotes as <code>[ -z \"${var+x}\" ]</code>, at the very small possible cost of an O(1) speed penalty.  The first author also added this as a comment next to the code using this solution giving the URL to this answer, which now also includes the explanation for why the quotes can be safely omitted.</p>\n\n<h2>The wrong way</h2>\n\n<pre><code>if [ -z \"$var\" ]; then echo \"var is unset\"; else echo \"var is set to '$var'\"; fi\n</code></pre>\n\n<p>This is because it doesn't distinguish between a variable that is unset and a variable that is set to the empty string. That is to say, if <code>var=''</code>, then the above solution will incorrectly output that var is unset.</p>\n\n<p>But this distinction is essential in situations where the user has to specify an extension, or additional list of properties, and that not specifying them defaults to a non-empty value, whereas specifying the empty string should make the script use an empty extension or list of additional properties.</p>\n\n<p></p>\n",
        "source": "so",
        "questionId": 3601515
      },
      {
        "title": "How do I iterate over a range of numbers defined by variables in Bash?",
        "body": "<pre><code>for i in $(seq 1 $END); do echo $i; done</code></pre>\n\n<p>edit: I prefer <code>seq</code> over the other methods because I can actually remember it ;)</p>\n",
        "source": "so",
        "questionId": 169511
      },
      {
        "title": "How to output MySQL query results in CSV format?",
        "body": "<p>From <a href=\"http://www.tech-recipes.com/rx/1475/save-mysql-query-results-into-a-text-or-csv-file/\" rel=\"noreferrer\">http://www.tech-recipes.com/rx/1475/save-mysql-query-results-into-a-text-or-csv-file/</a></p>\n\n<pre><code>SELECT order_id,product_name,qty\nFROM orders\nWHERE foo = 'bar'\nINTO OUTFILE '/var/lib/mysql-files/orders.csv'\nFIELDS TERMINATED BY ','\nENCLOSED BY '\"'\nLINES TERMINATED BY '\\n';\n</code></pre>\n\n<p>Using this command columns names will not be exported.</p>\n\n<p>Also note that <code>/var/lib/mysql-files/orders.csv</code> will be on the <em>server</em> that is running MySQL. The user that the MySQL process is running under must have permissions to write to the directory chosen, or the command will fail.</p>\n\n<p>If you want to write output to your local machine from a remote server (especially a hosted or virtualize machine such as Heroku or Amazon RDS), this solution is not suitable.</p>\n",
        "source": "so",
        "questionId": 356578
      },
      {
        "title": "Looping through the content of a file in Bash",
        "body": "<p>One way to do it is:</p>\n\n<pre><code>while read p; do\n  echo $p\ndone &lt;peptides.txt\n</code></pre>\n\n<hr>\n\n<p>Exceptionally, if the <a href=\"https://unix.stackexchange.com/questions/107800/using-while-loop-to-ssh-to-multiple-servers\">loop body may read from standard input</a>, you can open the file using a different file descriptor:</p>\n\n<pre><code>while read -u 10 p; do\n  ...\ndone 10&lt;peptides.txt\n</code></pre>\n\n<p>Here, 10 is just an arbitrary number (different from 0, 1, 2).</p>\n",
        "source": "so",
        "questionId": 1521462
      },
      {
        "title": "Converting string to lower case in Bash",
        "body": "<p>The are various ways:</p>\n\n<h3><a href=\"http://en.wikipedia.org/wiki/Tr_%28Unix%29\" rel=\"noreferrer\">tr</a></h3>\n\n<pre><code>$ echo \"$a\" | tr '[:upper:]' '[:lower:]'\nhi all\n</code></pre>\n\n<h3><a href=\"http://en.wikipedia.org/wiki/AWK\" rel=\"noreferrer\">AWK</a></h3>\n\n<pre><code>$ echo \"$a\" | awk '{print tolower($0)}'\nhi all\n</code></pre>\n\n<h3><a href=\"https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29\" rel=\"noreferrer\">Bash 4.0</a></h3>\n\n<pre><code>$ echo \"${a,,}\"\nhi all\n</code></pre>\n\n<h3><a href=\"http://en.wikipedia.org/wiki/Sed\" rel=\"noreferrer\">sed</a></h3>\n\n<pre><code>$ echo \"$a\" | sed -e 's/\\(.*\\)/\\L\\1/'\nhi all\n# this also works:\n$ sed -e 's/\\(.*\\)/\\L\\1/' &lt;&lt;&lt; \"$a\"\nhi all\n</code></pre>\n\n<h3><a href=\"http://en.wikipedia.org/wiki/Perl\" rel=\"noreferrer\">Perl</a></h3>\n\n<pre><code>$ echo \"$a\" | perl -ne 'print lc'\nhi all\n</code></pre>\n\n<h3><a href=\"https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29\" rel=\"noreferrer\">Bash</a></h3>\n\n<pre><code>lc(){\n    case \"$1\" in\n        [A-Z])\n        n=$(printf \"%d\" \"'$1\")\n        n=$((n+32))\n        printf \\\\$(printf \"%o\" \"$n\")\n        ;;\n        *)\n        printf \"%s\" \"$1\"\n        ;;\n    esac\n}\nword=\"I Love Bash\"\nfor((i=0;i&lt;${#word};i++))\ndo\n    ch=\"${word:$i:1}\"\n    lc \"$ch\"\ndone\n</code></pre>\n",
        "source": "so",
        "questionId": 2264428
      },
      {
        "title": "Loop through an array of strings in Bash?",
        "body": "<p>You can use it like this:</p>\n\n<pre><code>## declare an array variable\ndeclare -a arr=(\"element1\" \"element2\" \"element3\")\n\n## now loop through the above array\nfor i in \"${arr[@]}\"\ndo\n   echo \"$i\"\n   # or do whatever with individual element of the array\ndone\n\n# You can access them using echo \"${arr[0]}\", \"${arr[1]}\" also\n</code></pre>\n\n<p>Also works for multi-line array declaration</p>\n\n<pre><code>declare -a arr=(\"element1\" \n                \"element2\" \"element3\"\n                \"element4\"\n                )\n</code></pre>\n",
        "source": "so",
        "questionId": 8880603
      },
      {
        "title": "Difference between sh and bash",
        "body": "<h1>What is sh</h1>\n\n<p><code>sh</code> (or the Shell Command Language) is a programming language described by the <a href=\"http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html\" rel=\"noreferrer\">POSIX\nstandard</a>.\nIt has many implementations (<code>ksh88</code>, <code>dash</code>, ...). <code>bash</code> can also be\nconsidered an implementation of <code>sh</code> (see below).</p>\n\n<p>Because <code>sh</code> is a specification, not an implementation, <code>/bin/sh</code> is a symlink\n(or a hard link) to an actual implementation on most POSIX systems.</p>\n\n<h1>What is bash</h1>\n\n<p><code>bash</code> started as an <code>sh</code>-compatible implementation (although it predates the POSIX standard by a few years), but as time passed it has acquired many extensions. Many of these extensions may change the behavior of valid POSIX shell scripts, so by itself <code>bash</code> is not a valid POSIX shell. Rather, it is a dialect of the POSIX shell language.</p>\n\n<p><code>bash</code> supports a <code>--posix</code> switch, which makes it more POSIX-compliant. It also tries to mimic POSIX if invoked as <code>sh</code>.</p>\n\n<h1>sh = bash?</h1>\n\n<p>For a long time, <code>/bin/sh</code> used to point to <code>/bin/bash</code> on most GNU/Linux systems. As a result, it had almost become safe to ignore the difference between the two. But that started to change recently.</p>\n\n<p>Some popular examples of systems where <code>/bin/sh</code> does not point to <code>/bin/bash</code> (and on some of which <code>/bin/bash</code> may not even exist) are:</p>\n\n<ol>\n<li>Modern Debian and Ubuntu systems, which symlink <code>sh</code> to <code>dash</code> by default;</li>\n<li><a href=\"https://en.wikipedia.org/wiki/BusyBox\" rel=\"noreferrer\">Busybox</a>, which is usually run during the Linux system boot time as part of <code>initramfs</code>. It uses the <code>ash</code> shell implementation.</li>\n<li>BSDs, and in general any non-Linux systems. OpenBSD uses <code>pdksh</code>, a descendant of the Korn shell. FreeBSD's <code>sh</code> is a descendant of the original UNIX Bourne shell.  Solaris has its own <code>sh</code> which for a long time was not POSIX-compliant; a free implementation is available from the <a href=\"http://heirloom.sourceforge.net/sh.html\" rel=\"noreferrer\">Heirloom project</a>.</li>\n</ol>\n\n<p>How can you find out what <code>/bin/sh</code> points to on your system?</p>\n\n<p>The complication is that <code>/bin/sh</code> could be a symbolic link or a hard link.\nIf it's a symbolic link, a <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/utilities/file.html\" rel=\"noreferrer\">portable</a> way to resolve it is:</p>\n\n<pre><code>% file -h /bin/sh\n/bin/sh: symbolic link to bash\n</code></pre>\n\n<p>If it's a hard link, try</p>\n\n<pre><code>% find -L /bin -samefile /bin/sh\n/bin/sh\n/bin/bash\n</code></pre>\n\n<p>In fact, the <code>-L</code> flag covers both symlinks and hardlinks,\nbut the disadvantage of this method is that it is not portable —\nPOSIX <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html\" rel=\"noreferrer\">does not require</a> <code>find</code> to support the <code>-samefile</code> option,\nalthough both <a href=\"https://www.gnu.org/software/findutils/manual/html_mono/find.html#Hard-Links\" rel=\"noreferrer\">GNU find</a> and <a href=\"https://www.freebsd.org/cgi/man.cgi?find(1)\" rel=\"noreferrer\">FreeBSD find</a> support it.</p>\n\n<h1>Shebang line</h1>\n\n<p>Ultimately, it's up to you to decide which one to use, by writing the «shebang» line.</p>\n\n<p>E.g.</p>\n\n<pre><code>#!/bin/sh\n</code></pre>\n\n<p>will use <code>sh</code> (and whatever that happens to point to),</p>\n\n<pre><code>#!/bin/bash\n</code></pre>\n\n<p>will use <code>/bin/bash</code> if it's available (and fail with an error message if it's not). Of course, you can also specify another implementation, e.g.</p>\n\n<pre><code>#!/bin/dash\n</code></pre>\n\n<h1>Which one to use</h1>\n\n<p>For my own scripts, I prefer <code>sh</code> for the following reasons:</p>\n\n<ul>\n<li>it is standardized</li>\n<li>it is much simpler and easier to learn</li>\n<li>it is portable across POSIX systems — even if they happen not to have <code>bash</code>, they are required to have <code>sh</code></li>\n</ul>\n\n<p>There are advantages to using <code>bash</code> as well. Its features make programming more convenient and similar to programming in other modern programming languages. These include things like scoped local variables and arrays. Plain <code>sh</code> is a very minimalistic programming language.</p>\n",
        "source": "so",
        "questionId": 5725296
      },
      {
        "title": "Check existence of input argument in a Bash shell script",
        "body": "<p>It is:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>if [ $# -eq 0 ]\n  then\n    echo \"No arguments supplied\"\nfi\n</code></pre>\n\n<p>The <code>$#</code> variable will tell you the number of input arguments the script was passed.</p>\n\n<p>Or you can check if an argument is an empty string or not like:</p>\n\n<pre><code>if [ -z \"$1\" ]\n  then\n    echo \"No argument supplied\"\nfi\n</code></pre>\n\n<p>The <code>-z</code> switch will test if the expansion of \"$1\" is a null string or not. If it is a null string then the body is executed.</p>\n",
        "source": "so",
        "questionId": 6482377
      },
      {
        "title": "Make a Bash alias that takes a parameter?",
        "body": "<p>Bash alias does not directly accept parameters. You will have to create a function and alias that.</p>\n\n<p><code>alias</code> does not accept parameters but a function can be called just like an alias. For example:</p>\n\n<pre><code>myfunction() {\n    #do things with parameters like $1 such as\n    mv \"$1\" \"$1.bak\"\n    cp \"$2\" \"$1\"\n}\n\n\nmyFunction xyz #calls `myfunction`\n</code></pre>\n\n<p>By the way, Bash functions defined in your <code>.bashrc</code> and other files are available as commands within your shell. So for instance you can call the earlier function like this </p>\n\n<pre><code>$ myfunction original.conf my.conf\n</code></pre>\n",
        "source": "so",
        "questionId": 7131670
      },
      {
        "title": "Setting environment variables in OS X?",
        "body": "<p>Bruno is right on track.  I've done extensive research and if you want to set variables that are available in all GUI apps, your only option is <code>/etc/launchd.conf</code></p>\n\n<p>Please note that <a href=\"http://www.digitaledgesw.com/node/31\" rel=\"noreferrer\">environment.plist does not work for applications launched via Spotlight.  This is documented by Steve Sexton here</a>.</p>\n\n<p>1) Open a terminal prompt</p>\n\n<p>2) Type <code>sudo vi /etc/launchd.conf</code> (note: this file might not yet exist)</p>\n\n<p>3) Put contents like the following into the file</p>\n\n<pre class=\"lang-none prettyprint-override\"><code># Set environment variables here so they are available globally to all apps\n# (and Terminal), including those launched via Spotlight.\n#\n# After editing this file run the following command from the terminal to update \n# environment variables globally without needing to reboot.\n# NOTE: You will still need to restart the relevant application (including \n# Terminal) to pick up the changes!\n# grep -E \"^setenv\" /etc/launchd.conf | xargs -t -L 1 launchctl\n#\n# See http://www.digitaledgesw.com/node/31\n# and http://stackoverflow.com/questions/135688/setting-environment-variables-in-os-x/\n#\n# Note that you must hardcode the paths below, don't use enviroment variables.\n# You also need to surround multiple values in quotes, see MAVEN_OPTS example below.\n#\nsetenv JAVA_VERSION 1.6\nsetenv JAVA_HOME /System/Library/Frameworks/JavaVM.framework/Versions/1.6/Home\nsetenv GROOVY_HOME /Applications/Dev/groovy\nsetenv GRAILS_HOME /Applications/Dev/grails\nsetenv NEXUS_HOME /Applications/Dev/nexus/nexus-webapp\nsetenv JRUBY_HOME /Applications/Dev/jruby\n\nsetenv ANT_HOME /Applications/Dev/apache-ant\nsetenv ANT_OPTS -Xmx512M\n\nsetenv MAVEN_OPTS \"-Xmx1024M -XX:MaxPermSize=512m\"\nsetenv M2_HOME /Applications/Dev/apache-maven\n\nsetenv JMETER_HOME /Applications/Dev/jakarta-jmeter\n</code></pre>\n\n<p>4) Save your changes in VI and reboot your Mac. Or use the grep/xargs command which is shown in the code comment above.</p>\n\n<p>5) Prove that your variables are working by opening a Terminal window and typing <code>export</code> and you should see your new variables.  These will also be available in IntelliJ and other GUI apps you launch via Spotlight.</p>\n",
        "source": "so",
        "questionId": 135688
      },
      {
        "title": "echo that outputs to stderr",
        "body": "<p>This question is old, but you could do this, which facilitates reading:</p>\n\n<pre><code>&gt;&amp;2 echo \"error\"\n</code></pre>\n\n<p>The operator <code>&gt;&amp;2</code> literally means redirect the address of file descriptor 1 (<code>stdout</code>) to the address of file descriptor 2 (<code>stderr</code>) for that command<sup>1</sup>. Depending on how deeply you want to understand it, read this: <a href=\"http://wiki.bash-hackers.org/howto/redirection_tutorial\" rel=\"noreferrer\">http://wiki.bash-hackers.org/howto/redirection_tutorial</a></p>\n\n<p>To avoid interaction with other redirections use subshell</p>\n\n<pre><code>(&gt;&amp;2 echo \"error\")\n</code></pre>\n\n<hr>\n\n<p><sup>1</sup><sub><code>&gt;&amp;2</code> copies file descriptor #2 to file descriptor #1. Therefore, after this redirection is performed, both file descriptors will refer to the same file: the one file descriptor #2 was <strong>originally</strong> referring to.</sub></p>\n",
        "source": "so",
        "questionId": 2990414
      },
      {
        "title": "How to pipe stderr, and not stdout?",
        "body": "<p>First redirect stderr to stdout — the pipe; then redirect stdout to <code>/dev/null</code> (without changing where stderr is going):</p>\n\n<pre><code>command 2&gt;&amp;1 &gt;/dev/null | grep 'something'\n</code></pre>\n\n<p>For the details of I/O redirection in all its variety, see the chapter on <a href=\"http://www.gnu.org/software/bash/manual/bash.html#Redirections\" rel=\"noreferrer\">Redirections</a> in the Bash reference manual.</p>\n\n<p>Note that the sequence of I/O redirections is interpreted left-to-right, but pipes are set up before the I/O redirections are interpreted.  File descriptors such as 1 and 2 are references to open file descriptions.  The operation <code>2&gt;&amp;1</code> makes file descriptor 2 aka stderr refer to the same open file description as file descriptor 1 aka stdout is currently referring to (see <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/toc.htm\" rel=\"noreferrer\"><code>dup2()</code></a> and <a href=\"http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html#\" rel=\"noreferrer\"><code>open()</code></a>).  The operation <code>&gt;/dev/null</code> then changes file descriptor 1 so that it refers to an open file description for <code>/dev/null</code>, but that doesn't change the fact that file descriptor 2 refers to the open file description which file descriptor 1 was originally pointing to — namely, the pipe.</p>\n",
        "source": "so",
        "questionId": 2342826
      },
      {
        "title": "How to escape single quotes within single quoted strings?",
        "body": "<p>If you really want to use single quotes in the outermost layer, remember that you can glue both kinds of quotation. Example:</p>\n\n<pre><code> alias rxvt='urxvt -fg '\"'\"'#111111'\"'\"' -bg '\"'\"'#111111'\"'\"\n #                     ^^^^^       ^^^^^     ^^^^^       ^^^^\n #                     12345       12345     12345       1234\n</code></pre>\n\n<p>Explanation of how <code>'\"'\"'</code> is interpreted as just <code>'</code>:</p>\n\n<ol>\n<li><code>'</code> End first quotation which uses single quotes.</li>\n<li><code>\"</code> Start second quotation, using double-quotes.</li>\n<li><code>'</code> Quoted character.</li>\n<li><code>\"</code> End second quotation, using double-quotes.</li>\n<li><code>'</code> Start third quotation, using single quotes.</li>\n</ol>\n\n<p>If you do not place any whitespaces between (1) and (2), or between (4) and (5), the shell will interpret that string as a one long word.</p>\n",
        "source": "so",
        "questionId": 1250079
      },
      {
        "title": "YYYY-MM-DD format date in shell script",
        "body": "<p>In Bash: </p>\n\n<p>get <em>year-month-day</em> from <code>date</code></p>\n\n<pre><code>DATE=`date +%Y-%m-%d`\n</code></pre>\n\n<p>get <em>year-month-day hour:minute:second</em> from <code>date</code></p>\n\n<pre><code>DATE=`date '+%Y-%m-%d %H:%M:%S'`\n</code></pre>\n\n<p>Other available date formats can be viewed from the <a href=\"http://man7.org/linux/man-pages/man1/date.1.html\" rel=\"noreferrer\">date man pages</a>:</p>\n\n<pre><code>man date\n</code></pre>\n",
        "source": "so",
        "questionId": 1401482
      },
      {
        "title": "How to count lines in a document?",
        "body": "<p>Use <code>wc</code>:</p>\n\n<pre><code>wc -l &lt;filename&gt;\n</code></pre>\n\n<p>This will output the number of lines in <code>&lt;filename&gt;</code>:</p>\n\n<pre><code>$ wc -l /dir/file.txt\n3272485 /dir/file.txt\n</code></pre>\n\n<p>Or, to omit the <code>&lt;filename&gt;</code> from the result use <code>wc -l &lt; &lt;filename&gt;</code>:</p>\n\n<pre><code>$ wc -l &lt; /dir/file.txt\n3272485\n</code></pre>\n\n<p>You can also pipe data to <code>wc</code> as well:</p>\n\n<pre><code>$ cat /dir/file.txt | wc -l\n3272485\n$ curl yahoo.com --silent | wc -l\n63\n</code></pre>\n",
        "source": "so",
        "questionId": 3137094
      },
      {
        "title": "Pipe to/from the clipboard in Bash script",
        "body": "<p>You're a little ambiguous.  I expect you're probably a Linux user inside X who wants to put stuff in the X <code>PRIMARY</code> clipboard.</p>\n\n<p>It's important to understand that <code>bash</code> doesn't have a clipboard.  There is no such thing as \"the\" clipboard, because <code>bash</code> can run on Windows, Mac OS X, lots of other OSes, inside X, outside X, ...  Not to mention that X itself has three different clipboards.  There's a wealth of clipboards you could be dealing with.  Usually the clipboard you want to talk to has a utility that lets you talk to it.</p>\n\n<p>In case of X, yes, there's <code>xclip</code> (and others). <code>xclip -selection c</code> will send data to the clipboard that works with Ctrl-C, Ctrl-V in most applications.</p>\n\n<p>If you're trying to talk to the Mac OS X clipboard, there's <code>pbcopy</code>.</p>\n\n<p>If you're in Linux terminal mode (no X) then maybe you need to look into <code>gpm</code>.</p>\n\n<p>There's also <a href=\"http://www.gnu.org/software/screen/\" rel=\"noreferrer\">GNU <code>screen</code></a> which has a clipboard.  To put stuff in there, look at the <code>screen</code> command \"<code>readreg</code>\".</p>\n\n<p>Under Windows/cygwin, use <code>/dev/clipboard</code> or <code>clip</code> for newer versions of Windows (at least Windows 10).</p>\n",
        "source": "so",
        "questionId": 749544
      },
      {
        "title": "How to reload .bash_profile from the command line?",
        "body": "<p>Simply type <code>source ~/.bash_profile</code></p>\n\n<p>Alternatively, if you like saving keystrokes you can type <code>. ~/.bash_profile</code></p>\n",
        "source": "so",
        "questionId": 4608187
      },
      {
        "title": "What is the preferred Bash shebang?",
        "body": "<p>You should use <strong><code>#!/usr/bin/env bash</code></strong> for <a href=\"https://en.wikipedia.org/wiki/Shebang_%28Unix%29#Portability\">portability</a>: different *nixes put <code>bash</code> in different places, and using <code>/usr/bin/env</code> is a workaround to run the first <code>bash</code> found on the <code>PATH</code>. And <strong><a href=\"http://mywiki.wooledge.org/BashGuide/CommandsAndArguments#Scripts\"><code>sh</code> is not <code>bash</code></a></strong>.</p>\n",
        "source": "so",
        "questionId": 10376206
      },
      {
        "title": "Defining a variable with or without export",
        "body": "<p><code>export</code> makes the variable available to sub-processes.</p>\n\n<p>That is,</p>\n\n<pre><code>export name=value\n</code></pre>\n\n<p>means that the variable name is available to <em>any process</em> you run from that shell process. If you want a process to make use of this variable, use <code>export</code>, and run the process from that shell.</p>\n\n<pre><code>name=value\n</code></pre>\n\n<p>means the variable scope is restricted to the shell, and is not available to any other process. You would use this for (say) loop variables, temporary variables etc.</p>\n\n<p>It's important to note that exporting a variable doesn't make it available to parent processes. That is, specifying and exporting a variable in a spawned process doesn't make it available in the process that launched it.</p>\n",
        "source": "so",
        "questionId": 1158091
      },
      {
        "title": "Specify private SSH-key to use when executing shell command?",
        "body": "<p>Something like this should work (suggested by orip):</p>\n\n<pre><code>ssh-agent bash -c 'ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git'\n</code></pre>\n\n<p>if you prefer subshells, you could try the following (though it is more fragile):</p>\n\n<pre><code>ssh-agent $(ssh-add /somewhere/yourkey; git clone git@github.com:user/project.git)\n</code></pre>\n\n<p>Git will invoke SSH which will find its agent by environment variable; this will, in turn, have the key loaded.</p>\n\n<p>Alternatively, setting <code>HOME</code> may also do the trick, provided you are willing to setup a directory that contains only a <code>.ssh</code> directory as <code>HOME</code>; this may either contain an identity.pub, or a <a href=\"http://linux.die.net/man/5/ssh_config\" rel=\"noreferrer\">config file</a> setting IdentityFile.</p>\n",
        "source": "so",
        "questionId": 4565700
      },
      {
        "title": "Listing only directories using ls in bash: An examination",
        "body": "<p><code>*/</code> is a pattern that matches all of the subdirectories in the current directory (<code>*</code> would match all files <em>and</em> subdirectories; the <code>/</code> restricts it to directories). Similarly, to list all subdirectories under /home/alice/Documents, use <code>ls -d /home/alice/Documents/*/</code></p>\n",
        "source": "so",
        "questionId": 14352290
      },
      {
        "title": "How to iterate over arguments in a Bash script",
        "body": "<p>Use <code>\"$@\"</code> to represent all the arguments:</p>\n\n<pre><code>for var in \"$@\"\ndo\n    echo \"$var\"\ndone\n</code></pre>\n\n<p>This will iterate over each argument and print it out on a separate line.  $@ behaves like $* except that when quoted the arguments are broken up properly if there are spaces in them:</p>\n\n<pre><code>sh test.sh 1 2 '3 4'\n1\n2\n3 4\n</code></pre>\n",
        "source": "so",
        "questionId": 255898
      },
      {
        "title": "How can I exclude all &quot;permission denied&quot; messages from &quot;find&quot;?",
        "body": "<p><sup>Note:<br>\n* This answer probably goes deeper than the use case warrants, and <code>find 2&gt;/dev/null</code> may be good enough in many situations. It may still be of interest for a cross-platform perspective and for its discussion of some advanced shell techniques in the interest of finding a solution that is as robust as possible, even though the cases guarded against may be largely hypothetical.<br>\n* <strong>If your system is configured to show <em>localized</em> error messages</strong>, prefix the <code>find</code> calls below with <code>LC_ALL=C</code> (<code>LC_ALL=C find ...</code>) to ensure that <em>English</em> messages are reported, so that <code>grep -v 'Permission denied'</code> works as intended. Invariably, however, any error messages that <em>do</em> get displayed will then be in English as well.  </p>\n\n<p>If your <strong>shell is <code>bash</code> or <code>zsh</code></strong>, there's <strong>a solution that is robust while being reasonably simple</strong>, using <strong>only POSIX-compliant <code>find</code> features</strong>; while <code>bash</code> itself is not part of POSIX, most modern Unix platforms come with it, making this solution widely portable:</p>\n\n<pre><code>find . &gt; files_and_folders 2&gt; &gt;(grep -v 'Permission denied' &gt;&amp;2)\n</code></pre>\n\n<p>Note: There's a small chance that some of <code>grep</code>'s output may arrive <em>after</em> <code>find</code> completes, because the overall command doesn't wait for the command inside <code>&gt;(...)</code> to finish. In <code>bash</code>, you can prevent this by appending <code>| cat</code> to the command.</sup></p>\n\n<ul>\n<li><p><code>&gt;(...)</code> is a (rarely used) <em>output</em> <a href=\"http://mywiki.wooledge.org/ProcessSubstitution\" rel=\"noreferrer\">process substitution</a> that allows redirecting output (in this case, <em>stderr</em> output (<code>2&gt;</code>) to the stdin of the command inside <code>&gt;(...)</code>.<br>\nIn addition to <code>bash</code>, and <code>zsh</code>, <code>ksh</code> supports them as well in principle, but trying to combine them with redirection from <em>stderr</em>, as is done here (<code>2&gt; &gt;(...)</code>), appears to be silently ignored (in <code>ksh 93u+</code>).</p>\n\n<ul>\n<li><code>grep -v 'Permission denied'</code> filters <em>out</em> (<code>-v</code>) all lines (from the <code>find</code> command's stderr stream) that contain the phrase <code>Permission denied</code> and outputs the remaining lines to stderr (<code>&gt;&amp;2</code>).</li>\n</ul></li>\n</ul>\n\n<p>This approach is:</p>\n\n<ul>\n<li><p><strong>robust</strong>: <code>grep</code> is only applied to <em>error messages</em> (and not to a combination of file paths and error messages, potentially leading to false positives), and error messages other than permission-denied ones are passed through, to stderr.</p></li>\n<li><p><strong>side-effect free</strong>: <code>find</code>'s exit code is preserved: the inability to access at least one of the filesystem items encountered results in exit code <code>1</code> (although that won't tell you whether errors <em>other</em> than permission-denied ones occurred (too)).</p></li>\n</ul>\n\n<hr>\n\n<h3>POSIX-compliant solutions:</h3>\n\n<p>Fully POSIX-compliant solutions either have limitations or require additional work.</p>\n\n<p><strong>If <code>find</code>'s output is to be captured in a <em>file</em> anyway</strong> (or suppressed altogether), then the pipeline-based solution from <a href=\"https://stackoverflow.com/a/762360/45375\">Jonathan Leffler's answer</a> is simple, robust, and POSIX-compliant:</p>\n\n<pre><code>find . 2&gt;&amp;1 &gt;files_and_folders | grep -v 'Permission denied' &gt;&amp;2\n</code></pre>\n\n<p>Note that the order of the redirections matters: <code>2&gt;&amp;1</code> must come <em>first</em>.</p>\n\n<p>Capturing stdout output in a file up front allows <code>2&gt;&amp;1</code> to send <em>only</em> error messages through the pipeline, which <code>grep</code> can then unambiguously operate on.</p>\n\n<p>The <strong>only downside is that the <em>overall exit code</em> will be the <code>grep</code> command's</strong>, not <code>find</code>'s, which in this case means: if there are <em>no</em> errors at all or <em>only</em> permission-denied errors, the exit code will be <code>1</code> (signaling <em>failure</em>), otherwise (errors other than permission-denied ones) <code>0</code> - which is the opposite of the intent.<br>\n<strong>That said, <code>find</code>'s exit code is rarely used anyway</strong>, as it often conveys little information beyond <em>fundamental</em> failure such as passing a non-existent path.<br>\nHowever, the specific case of even only <em>some</em> of the input paths being inaccessible due to lack of permissions <em>is</em> reflected in <code>find</code>'s exit code (in both GNU and BSD <code>find</code>): if a permissions-denied error occurs for <em>any</em> of the files processed, the exit code is set to <code>1</code>.</p>\n\n<p>The following variation addresses that:</p>\n\n<pre><code>find . 2&gt;&amp;1 &gt;files_and_folders | { grep -v 'Permission denied' &gt;&amp;2; [ $? -eq 1 ]; }\n</code></pre>\n\n<p>Now, the exit code indicates whether any errors <em>other than</em> <code>Permission denied</code> occurred: <code>1</code> if so, <code>0</code> otherwise.<br>\nIn other words: the exit code now reflects the true intent of the command: success (<code>0</code>) is reported, if no errors at all or <em>only</em> permission-denied errors occurred.<br>\nThis is arguably even better than just passing <code>find</code>'s exit code through, as in the solution at the top.</p>\n\n<hr>\n\n<p><a href=\"https://stackoverflow.com/users/1815797/gniourf-gniourf\">gniourf_gniourf</a> in the comments proposes a (still POSIX-compliant) <strong>generalization of this solution using sophisticated redirections</strong>, which <strong>works even with the default behavior of printing the file paths to <em>stdout</em></strong>:</p>\n\n<pre><code>{ find . 3&gt;&amp;2 2&gt;&amp;1 1&gt;&amp;3 | grep -v 'Permission denied' &gt;&amp;3; } 3&gt;&amp;2 2&gt;&amp;1\n</code></pre>\n\n<p>In short: Custom file descriptor <code>3</code> is used to temporarily swap stdout (<code>1</code>) and stderr (<code>2</code>), so that error messages <em>alone</em> can be piped to <code>grep</code> via stdout.</p>\n\n<p>Without these redirections, both data (file paths) <em>and</em> error messages would be piped to <code>grep</code> via stdout, and <code>grep</code> would then not be able to distinguish between <em>error message</em> <code>Permission denied</code> and a (hypothetical) <em>file whose name happens to contain</em> the phrase <code>Permission denied</code>.</p>\n\n<p>As in the first solution, however, the the exit code reported will be <code>grep</code>'s, not <code>find</code>'s, but the same fix as above can be applied.</p>\n\n<hr>\n\n<h3>Notes on the existing answers:</h3>\n\n<ul>\n<li><p>There are several points to note about <a href=\"https://stackoverflow.com/a/25234419/45375\">Michael Brux's answer</a>, <code>find . ! -readable -prune -o -print</code>:</p>\n\n<ul>\n<li><p>It requires <em>GNU</em> <code>find</code>; notably, it won't work on macOS. Of course, if you only ever need the command to work with GNU <code>find</code>, this won't be a problem for you.</p></li>\n<li><p>Some <code>Permission denied</code> errors may <em>still</em> surface: <code>find ! -readable -prune</code> reports such errors for the <em>child</em> items of directories for which the current user does have <code>r</code> permission, but lacks <code>x</code> (executable) permission. The reason is that because the directory itself <em>is</em> readable, <code>-prune</code> is not executed, and the attempt to descend <em>into</em> that directory then triggers the error messages. That said, the <em>typical</em> case is for the <code>r</code> permission to be missing.</p></li>\n<li><p>Note: The following point is a matter of philosophy and/or specific use case, and you may decide it is not relevant to you and that the command fits your needs well, especially if simply <em>printing</em> the paths is all you do:</p>\n\n<ul>\n<li><em>If</em> you conceptualize the filtering of the permission-denied error messages a <em>separate</em> task that you want to be able to apply to <em>any</em> <code>find</code> command, then the opposite approach of proactively <em>preventing</em> permission-denied errors requires introducing \"noise\" into the <code>find</code> command, which also introduces complexity and logical <em>pitfalls</em>.</li>\n<li>For instance, the most up-voted comment on Michael's answer (as of this writing) attempts to show how to <em>extend</em> the command by including a <code>-name</code> filter, as follows:<br>\n<code>find . ! -readable -prune -o -name '*.txt'</code><br>\nThis, however, does <em>not</em> work as intended, because the trailing <code>-print</code> action is <em>required</em> (an explanation can be found in <a href=\"https://stackoverflow.com/questions/1489277/how-to-use-prune-option-of-find-in-sh\">this answer</a>). Such subtleties can introduce bugs.</li>\n</ul></li>\n</ul></li>\n<li><p>The first solution in <a href=\"https://stackoverflow.com/a/762360/45375\">Jonathan Leffler's answer</a>, <code>find . 2&gt;/dev/null &gt; files_and_folders</code>, as he himself states,  <strong>blindly silences <em>all</em> error messages</strong> (and the workaround is cumbersome and not fully robust, as he also explains). <strong>Pragmatically speaking</strong>, however, it is the <strong>simplest solution</strong>, as you may be content to assume that any and all errors would be permission-related.</p></li>\n<li><p><a href=\"https://stackoverflow.com/a/27503763/45375\">mist's answer</a>, <code>sudo find . &gt; files_and_folders</code>, <strong>is concise and pragmatic, but ill-advised for anything other than merely <em>printing</em> filenames</strong>, for security reasons: because you're running as the <em>root</em> user, \"you risk having your whole system being messed up by a bug in find or a malicious version, or an incorrect invocation which writes something unexpectedly, which could not happen if you ran this with normal privileges\" (from a comment on mist's answer by <a href=\"https://stackoverflow.com/users/874188/tripleee\">tripleee</a>).  </p></li>\n<li><p>The 2nd solution in <a href=\"https://stackoverflow.com/a/762377/45375\">viraptor's answer</a>, <code>find . 2&gt;&amp;1 | grep -v 'Permission denied' &gt; some_file</code> runs the risk of false positives (due to sending a mix of stdout and stderr through the pipeline), and, potentially, instead of reporting <em>non</em>-permission-denied errors via stderr, captures them alongside the output paths in the output file.</p></li>\n</ul>\n",
        "source": "so",
        "questionId": 762348
      },
      {
        "title": "Passing parameters to a Bash function",
        "body": "<p>There are two typical ways of declaring a function. I prefer the second approach.</p>\n\n<pre><code>function function_name {\n   command...\n} \n</code></pre>\n\n<p>or </p>\n\n<pre><code>function_name () {\n   command...\n} \n</code></pre>\n\n<p>To call a function with arguments:</p>\n\n<pre><code>function_name \"$arg1\" \"$arg2\"\n</code></pre>\n\n<p>The function refers to passed arguments by their position (not by name), that is $1, $2, and so forth. <strong>$0</strong> is the name of the script itself.</p>\n\n<p>Example:</p>\n\n<pre><code>function_name () {\n   echo \"Parameter #1 is $1\"\n}\n</code></pre>\n\n<p>Also, you need to call your function <strong>after</strong> it is declared. </p>\n\n<pre><code>#!/usr/bin/env sh\n\nfoo 1  # this will fail because foo has not been declared yet.\n\nfoo() {\n    echo \"Parameter #1 is $1\"\n}\n\nfoo 2 # this will work.\n</code></pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"lang-none prettyprint-override\"><code>./myScript.sh: line 2: foo: command not found\nParameter #1 is 2\n</code></pre>\n\n<p><a href=\"http://tldp.org/LDP/abs/html/complexfunct.html\" rel=\"noreferrer\">Reference: Advanced Bash-Scripting Guide</a>.</p>\n",
        "source": "so",
        "questionId": 6212219
      },
      {
        "title": "How to trim whitespace from a Bash variable?",
        "body": "<p>Let's define a variable containing leading, trailing, and intermediate whitespace:</p>\n\n<pre><code>FOO=' test test test '\necho -e \"FOO='${FOO}'\"\n# &gt; FOO=' test test test '\necho -e \"length(FOO)==${#FOO}\"\n# &gt; length(FOO)==16\n</code></pre>\n\n<hr>\n\n<p>How to remove all whitespace (denoted by <code>[:space:]</code> in <code>tr</code>):</p>\n\n<pre><code>FOO=' test test test '\nFOO_NO_WHITESPACE=\"$(echo -e \"${FOO}\" | tr -d '[:space:]')\"\necho -e \"FOO_NO_WHITESPACE='${FOO_NO_WHITESPACE}'\"\n# &gt; FOO_NO_WHITESPACE='testtesttest'\necho -e \"length(FOO_NO_WHITESPACE)==${#FOO_NO_WHITESPACE}\"\n# &gt; length(FOO_NO_WHITESPACE)==12\n</code></pre>\n\n<hr>\n\n<p>How to remove leading whitespace only:</p>\n\n<pre><code>FOO=' test test test '\nFOO_NO_LEAD_SPACE=\"$(echo -e \"${FOO}\" | sed -e 's/^[[:space:]]*//')\"\necho -e \"FOO_NO_LEAD_SPACE='${FOO_NO_LEAD_SPACE}'\"\n# &gt; FOO_NO_LEAD_SPACE='test test test '\necho -e \"length(FOO_NO_LEAD_SPACE)==${#FOO_NO_LEAD_SPACE}\"\n# &gt; length(FOO_NO_LEAD_SPACE)==15\n</code></pre>\n\n<hr>\n\n<p>How to remove trailing whitespace only:</p>\n\n<pre><code>FOO=' test test test '\nFOO_NO_TRAIL_SPACE=\"$(echo -e \"${FOO}\" | sed -e 's/[[:space:]]*$//')\"\necho -e \"FOO_NO_TRAIL_SPACE='${FOO_NO_TRAIL_SPACE}'\"\n# &gt; FOO_NO_TRAIL_SPACE=' test test test'\necho -e \"length(FOO_NO_TRAIL_SPACE)==${#FOO_NO_TRAIL_SPACE}\"\n# &gt; length(FOO_NO_TRAIL_SPACE)==15\n</code></pre>\n\n<hr>\n\n<p>How to remove both leading and trailing spaces--chain the <code>sed</code>s:</p>\n\n<pre><code>FOO=' test test test '\nFOO_NO_EXTERNAL_SPACE=\"$(echo -e \"${FOO}\" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')\"\necho -e \"FOO_NO_EXTERNAL_SPACE='${FOO_NO_EXTERNAL_SPACE}'\"\n# &gt; FOO_NO_EXTERNAL_SPACE='test test test'\necho -e \"length(FOO_NO_EXTERNAL_SPACE)==${#FOO_NO_EXTERNAL_SPACE}\"\n# &gt; length(FOO_NO_EXTERNAL_SPACE)==14\n</code></pre>\n\n<p>Alternatively, if your bash supports it, you can replace <code>echo -e \"${FOO}\" | sed ...</code> with <code>sed ... &lt;&lt;&lt;${FOO}</code>, like so (for trailing whitespace):</p>\n\n<pre><code>FOO_NO_TRAIL_SPACE=\"$(sed -e 's/[[:space:]]*$//' &lt;&lt;&lt;${FOO})\"\n</code></pre>\n",
        "source": "so",
        "questionId": 369758
      },
      {
        "title": "Redirect all output to file",
        "body": "<p>That part is written to stderr, use <code>2&gt;</code> to redirect it. For example:</p>\n\n<pre><code>foo &gt; stdout.txt 2&gt; stderr.txt\n</code></pre>\n\n<p>or if you want in same file:</p>\n\n<pre><code>foo &gt; allout.txt 2&gt;&amp;1\n</code></pre>\n\n<p>Note: this works in (ba)sh, check your shell for proper syntax</p>\n",
        "source": "so",
        "questionId": 6674327
      },
      {
        "title": "What are the special dollar sign shell variables?",
        "body": "<ul>\n<li><code>$1</code>, <code>$2</code>, <code>$3</code>, ... are the <a href=\"https://www.gnu.org/software/bash/manual/html_node/Positional-Parameters.html\" rel=\"noreferrer\">positional parameters</a>.</li>\n<li><code>\"$@\"</code> is an array-like construct of all positional parameters, <code>{$1, $2, $3 ...}</code>.</li>\n<li><code>\"$*\"</code> is the IFS expansion of all positional parameters, <code>$1 $2 $3 ...</code>.</li>\n<li><code>$#</code> is the number of positional parameters.</li>\n<li><code>$-</code> current options set for the shell.</li>\n<li><code>$$</code> pid of the current shell (not subshell).</li>\n<li><code>$_</code> most recent parameter (or the abs path of the command to start the current shell immediately after startup).</li>\n<li><code>$IFS</code> is the (input) field separator.</li>\n<li><code>$?</code> is the most recent foreground pipeline exit status.</li>\n<li><code>$!</code> is the PID of the most recent background command.</li>\n<li><code>$0</code> is the name of the shell or shell script.</li>\n</ul>\n\n<p>Most of the above can be found under <a href=\"https://www.gnu.org/software/bash/manual/html_node/Special-Parameters.html\" rel=\"noreferrer\">Special Parameters</a> in the Bash Reference Manual. There are all the <a href=\"https://www.gnu.org/software/bash/manual/html_node/Shell-Variables.html\" rel=\"noreferrer\">environment variables set by the shell</a>.</p>\n\n<p>For a comprehensive index, please see the <a href=\"https://www.gnu.org/software/bash/manual/html_node/Variable-Index.html\" rel=\"noreferrer\">Reference Manual Variable Index</a>.</p>\n",
        "source": "so",
        "questionId": 5163144
      },
      {
        "title": "How to redirect output to a file and stdout",
        "body": "<p>The command you want is named <strong><a href=\"http://www.gnu.org/software/coreutils/manual/html_node/tee-invocation.html\" rel=\"noreferrer\"><code>tee</code></a></strong>:</p>\n\n<pre><code>foo | tee output.file\n</code></pre>\n\n<p>For example, if you only care about stdout:</p>\n\n<pre><code>ls -a | tee output.file\n</code></pre>\n\n<p>If you want to include stderr, do:</p>\n\n<pre><code>program [arguments...] 2&gt;&amp;1 | tee outfile\n</code></pre>\n\n<p><code>2&gt;&amp;1</code> redirects channel 2 (stderr/standard error) into channel 1 (stdout/standard output), such that both is written as stdout. It is also directed to the given output file as of the <code>tee</code> command.</p>\n\n<p>Furthermore, if you want to <em>append</em> to the log file, use <code>tee -a</code> as:</p>\n\n<pre><code>program [arguments...] 2&gt;&amp;1 | tee -a outfile\n</code></pre>\n",
        "source": "so",
        "questionId": 418896
      },
      {
        "title": "How to declare and use boolean variables in shell script?",
        "body": "<p><strong>Revised Answer (Feb 12, 2014)</strong></p>\n\n<pre><code>the_world_is_flat=true\n# ...do something interesting...\nif [ \"$the_world_is_flat\" = true ] ; then\n    echo 'Be careful not to fall off!'\nfi\n</code></pre>\n\n<hr>\n\n<p><strong>Original Answer</strong></p>\n\n<p>Caveats: <a href=\"https://stackoverflow.com/a/21210966/89391\">https://stackoverflow.com/a/21210966/89391</a></p>\n\n<pre><code>the_world_is_flat=true\n# ...do something interesting...\nif $the_world_is_flat ; then\n    echo 'Be careful not to fall off!'\nfi\n</code></pre>\n\n<p>From: <a href=\"https://github.com/aperezdc/perezdecastro.org/blob/master/stash/using-boolean-variables-in-bash.markdown\" rel=\"noreferrer\">Using boolean variables in Bash</a></p>\n\n<p><em>The reason the original answer is included here is because the comments before the revision on Feb 12, 2014 pertain only to the original answer, and many of the comments are wrong when associated with the revised answer. For example, Dennis Williamson's comment about bash builtin <code>true</code> on Jun 2, 2010 only applies to the original answer, not the revised.</em></p>\n",
        "source": "so",
        "questionId": 2953646
      },
      {
        "title": "Get current directory name (without full path) in a Bash script",
        "body": "<p>No need for basename, and especially no need for a subshell running pwd (which <A HREF=\"http://mywiki.wooledge.org/SubShell\" rel=\"noreferrer\">adds an extra, and expensive, fork operation</A>); the shell can do this internally using <A HREF=\"http://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html\" rel=\"noreferrer\">parameter expansion</A>:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>result=${PWD##*/}          # to assign to a variable\n\nprintf '%s\\n' \"${PWD##*/}\" # to print to stdout\n                           # ...more robust than echo for unusual names\n                           #    (consider a directory named -e or -n)\n\nprintf '%q\\n' \"${PWD##*/}\" # to print to stdout, quoted for use as shell input\n                           # ...useful to make hidden characters readable.\n</code></pre>\n",
        "source": "so",
        "questionId": 1371261
      },
      {
        "title": "Count number of lines in a git repository",
        "body": "<p><code>xargs</code> will do what you want:</p>\n\n<pre><code>git ls-files | xargs cat | wc -l\n</code></pre>\n\n<p>But with more information and probably better, you can do:</p>\n\n<pre><code>git ls-files | xargs wc -l\n</code></pre>\n",
        "source": "so",
        "questionId": 4822471
      },
      {
        "title": "How to compare strings in Bash",
        "body": "<p>Try this:</p>\n\n<pre><code>if [ \"$x\" = \"valid\" ]; then\n  echo \"x has the value 'valid'\"\nfi\n</code></pre>\n\n<p>If you want to do something when they don't match, replace <code>=</code> with <code>!=</code>. You want the quotes around <code>$x</code>, because if <code>$x</code> is empty, you'll get <code>if [ = \"valid\" ]...</code> which is a syntax error.</p>\n\n<hr>\n\n<p>Note that <code>bash</code> allows <code>==</code> to be used with <code>[</code>, but this is not standard. Either use <code>[[ \"$x\" == \"valid\" ]]</code> (in which case, the quotes around <code>$x</code> are optional) or <code>[ \"$x\" = \"valid\" ]</code>.</p>\n",
        "source": "so",
        "questionId": 2237080
      },
      {
        "title": "How do I remove all .pyc files from a project?",
        "body": "<pre><code>find . -name \"*.pyc\" -exec rm -f {} \\;\n</code></pre>\n\n<p>as mentioned in the comments, you can also use the <code>-delete</code> action</p>\n\n<pre><code>find . -name \\*.pyc -delete\n</code></pre>\n",
        "source": "so",
        "questionId": 785519
      },
      {
        "title": "How to use double or single brackets, parentheses, curly braces",
        "body": "<p>In Bash, <code>test</code> and <code>[</code> are builtins.</p>\n\n<p>The <a href=\"http://mywiki.wooledge.org/BashFAQ/031\" rel=\"noreferrer\">double bracket</a> enables additional functionality. For example, you can use <code>&amp;&amp;</code> and <code>||</code> instead of <code>-a</code> and <code>-o</code> and there's a regular expression matching operator <code>=~</code>.</p>\n\n<p>The braces, in addition to delimiting a variable name are used for <a href=\"http://tiswww.case.edu/php/chet/bash/bashref.html#SEC31\" rel=\"noreferrer\">parameter expansion</a> so you can do things like:</p>\n\n<ul>\n<li><p>Truncate the contents of a variable</p>\n\n<p><code>$ var=\"abcde\"; echo ${var%d*}</code><br>\n<code>abc</code></p></li>\n<li><p>Make substitutions similar to <code>sed</code></p>\n\n<p><code>$ var=\"abcde\"; echo ${var/de/12}</code><br>\n<code>abc12</code></p></li>\n<li><p>Use a default value</p>\n\n<p><code>$ default=\"hello\"; unset var; echo ${var:-$default}</code><br>\n<code>hello</code></p></li>\n<li><p>and several more</p></li>\n</ul>\n\n<p>Also, brace expansions create lists of strings which are typically iterated over in loops:</p>\n\n<pre><code>$ echo f{oo,ee,a}d\nfood feed fad\n\n$ mv error.log{,.OLD}\n(error.log is renamed to error.log.OLD because the brace expression\nexpands to \"mv error.log error.log.OLD\")\n\n$ for num in {000..2}; do echo \"$num\"; done\n000\n001\n002\n\n$ echo {00..8..2}\n00 02 04 06 08\n\n$ echo {D..T..4}\nD H L P T\n</code></pre>\n\n<p>Note that the leading zero and increment features weren't available before Bash 4.</p>\n\n<p>Thanks to gboffi for reminding me about brace expansions.</p>\n\n<p>Double parentheses are used for <a href=\"http://tiswww.case.edu/php/chet/bash/bashref.html#SEC33\" rel=\"noreferrer\">arithmetic operations</a>:</p>\n\n<pre><code>((a++))\n\n((meaning = 42))\n\nfor ((i=0; i&lt;10; i++))\n\necho $((a + b + (14 * c)))\n</code></pre>\n\n<p>and they enable you to omit the dollar signs on integer and array variables and include spaces around operators for readability.</p>\n\n<p>Single brackets are also used for <a href=\"http://tiswww.case.edu/php/chet/bash/bashref.html#SEC85\" rel=\"noreferrer\">array</a> indices:</p>\n\n<pre><code>array[4]=\"hello\"\n\nelement=${array[index]}\n</code></pre>\n\n<p>Curly brace are required for (most/all?) array references on the right hand side.</p>\n\n<p><strong>ephemient's</strong> comment reminded me that parentheses are also used for subshells. And that they are used to create arrays.</p>\n\n<pre><code>array=(1 2 3)\necho ${array[1]}\n2\n</code></pre>\n",
        "source": "so",
        "questionId": 2188199
      },
      {
        "title": "How to &#39;grep&#39; a continuous stream?",
        "body": "<p>Turn on <code>grep</code>'s line buffering mode when using BSD grep (FreeBSD, Mac OS X etc.)</p>\n\n<pre><code>tail -f file | grep --line-buffered my_pattern\n</code></pre>\n\n<p>You don't need to do this for GNU grep (used on pretty much any Linux) as it will flush by default (YMMV for other Unix-likes such as SmartOS, AIX or QNX).</p>\n",
        "source": "so",
        "questionId": 7161821
      },
      {
        "title": "Why is whitespace sometimes needed around metacharacters?",
        "body": "<p>There is a list of characters that separate tokens in BASH. These characters are called <em>metacharacters</em> and they are <code>|</code>, <code>&amp;</code>, <code>;</code>, <code>(</code>, <code>)</code>, <code>&lt;</code>, <code>&gt;</code>, <strong>space</strong> and <strong>tab</strong>. On the other hand, curly braces (<code>{</code> and <code>}</code>) are just ordinary characters that make up words.</p>\n\n<p>Omitting the second space before <code>}</code> will do, since <code>&amp;</code> is a metacharacter. Therefore, your tattoo should have at least one space character.</p>\n\n<pre><code>:(){ :|:&amp;};:\n</code></pre>\n",
        "source": "so",
        "questionId": 21186724
      },
      {
        "title": "How do I clear/delete the current line in terminal?",
        "body": "<p>You can use <kbd>Ctrl</kbd>+<kbd>U</kbd> to clear up to the beginning.</p>\n\n<p>You can use <kbd>Ctrl</kbd>+<kbd>W</kbd> to delete just a word.</p>\n\n<p>You can also use <kbd>Ctrl</kbd>+<kbd>C</kbd> to cancel.</p>\n\n<p>If you want to keep the history, you can use <kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd>#</kbd> to make it a comment.</p>\n\n<hr>\n\n<p><sub><a href=\"http://www.catonmat.net/blog/bash-emacs-editing-mode-cheat-sheet/\" rel=\"noreferrer\">Bash Emacs Editing Mode Cheat Sheet</a></sub></p>\n",
        "source": "so",
        "questionId": 9679776
      },
      {
        "title": "Propagate all arguments in a bash shell script",
        "body": "<p>Use <code>\"$@\"</code> instead of plain <code>$@</code> if you actually wish your parameters to be passed the same.</p>\n\n<p>Observe:</p>\n\n<pre><code>$ cat foo.sh\n#!/bin/bash\nbaz.sh $@\n\n$ cat bar.sh\n#!/bin/bash\nbaz.sh \"$@\"\n\n$ cat baz.sh\n#!/bin/bash\necho Received: $1\necho Received: $2\necho Received: $3\necho Received: $4\n\n$ ./foo.sh first second\nReceived: first\nReceived: second\nReceived:\nReceived:\n\n$ ./foo.sh \"one quoted arg\"\nReceived: one\nReceived: quoted\nReceived: arg\nReceived:\n\n$ ./bar.sh first second\nReceived: first\nReceived: second\nReceived:\nReceived:\n\n$ ./bar.sh \"one quoted arg\"\nReceived: one quoted arg\nReceived:\nReceived:\nReceived:\n</code></pre>\n",
        "source": "so",
        "questionId": 4824590
      },
      {
        "title": "Given two directory trees, how can I find out which files differ?",
        "body": "<p>You said Linux, so you luck out (at least it should be available, not sure when it was added):</p>\n\n<pre><code>diff --brief -r dir1/ dir2/\n</code></pre>\n\n<p>Should do what you need.</p>\n\n<p>If you also want to see differences for files that may not exist in either directory:</p>\n\n<pre><code>diff --brief -Nr dir1/ dir2/\n</code></pre>\n",
        "source": "so",
        "questionId": 4997693
      },
      {
        "title": "Redirect stderr and stdout in Bash",
        "body": "<p>Take a look <a href=\"http://tldp.org/LDP/abs/html/io-redirection.html\" rel=\"noreferrer\">here</a>. Should be:</p>\n\n<pre><code>yourcommand &amp;&gt;filename\n</code></pre>\n\n<p>(redirects both <code>stdout</code> and <code>stderr</code> to filename).</p>\n",
        "source": "so",
        "questionId": 637827
      },
      {
        "title": "How to permanently set $PATH on Linux/Unix?",
        "body": "<p><strong>You need to add it to your <code>~/.profile</code> or <code>~/.bashrc</code> file.</strong></p>\n\n<pre><code>export PATH=$PATH:/path/to/dir\n</code></pre>\n\n<p>Depending on what you're doing, you also may want to symlink to binaries:</p>\n\n<pre><code>cd /usr/bin\nsudo ln -s /path/to/binary binary-name\n</code></pre>\n\n<p><strong>Note that this will not automatically update your path for the remainder of the session.</strong> To do this, you should run:</p>\n\n<pre><code>source ~/.profile \nor\nsource ~/.bashrc\n</code></pre>\n",
        "source": "so",
        "questionId": 14637979
      },
      {
        "title": "Add line break to &#39;git commit -m&#39; from the command line",
        "body": "<p>Certainly, how it's done depends on your shell. In Bash, you can use single quotes around the message and can just leave the quote open, which will make Bash prompt for another line, until you close the quote. Like this:</p>\n\n<pre><code>git commit -m 'Message\ngoes\nhere'\n</code></pre>\n\n<p>Alternatively, you can use a \"here document\":</p>\n\n<pre><code>git commit -F- &lt;&lt;EOF\nMessage\ngoes\nhere\nEOF\n</code></pre>\n",
        "source": "so",
        "questionId": 5064563
      },
      {
        "title": "How can I write a heredoc to a file in Bash script?",
        "body": "<p>Read the Advanced Bash-Scripting Guide <a href=\"http://tldp.org/LDP/abs/html/here-docs.html\" rel=\"noreferrer\">Chapter 19. Here Documents</a>.</p>\n\n<p>Here's an example which will write the contents to a file at <code>/tmp/yourfilehere</code></p>\n\n<pre><code>cat &lt;&lt; EOF &gt; /tmp/yourfilehere\nThese contents will be written to the file.\n        This line is indented.\nEOF\n</code></pre>\n\n<p>Note that the final 'EOF' (The <code>LimitString</code>) should not have any whitespace in front of the word, because it means that the <code>LimitString</code> will not be recognized.</p>\n\n<p>In a shell script, you may want to use indentation to make the code readable, however this can have the undesirable effect of indenting the text within your here document. In this case, use <code>&lt;&lt;-</code> (followed by a dash) to disable leading tabs (<strong>Note</strong> that to test this you will need to <strong>replace the leading whitespace with a tab character</strong>, since I cannot print actual tab characters here.)</p>\n\n<pre><code>#!/usr/bin/env bash\n\nif true ; then\n    cat &lt;&lt;- EOF &gt; /tmp/yourfilehere\n    The leading tab is ignored.\n    EOF\nfi\n</code></pre>\n\n<p>If you don't want to interpret variables in the text, then use single quotes:</p>\n\n<pre><code>cat &lt;&lt; 'EOF' &gt; /tmp/yourfilehere\nThe variable $FOO will not be interpreted.\nEOF\n</code></pre>\n\n<p>To pipe the heredoc through a command pipeline:</p>\n\n<pre><code>cat &lt;&lt;'EOF' |  sed 's/a/b/'\nfoo\nbar\nbaz\nEOF\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>foo\nbbr\nbbz\n</code></pre>\n\n<p>... or to write the the heredoc to a file using <code>sudo</code>:</p>\n\n<pre><code>cat &lt;&lt;'EOF' |  sed 's/a/b/' | sudo tee /etc/config_file.conf\nfoo\nbar\nbaz\nEOF\n</code></pre>\n",
        "source": "so",
        "questionId": 2953081
      },
      {
        "title": "Add a new element to an array without specifying the index in Bash",
        "body": "<p>Yes there is:</p>\n\n<pre><code>ARRAY=()\nARRAY+=('foo')\nARRAY+=('bar')\n</code></pre>\n\n<p><a href=\"http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameters\" rel=\"noreferrer\">Bash Reference Manual</a>:</p>\n\n<blockquote>\n  <p>In the context where an assignment statement is assigning a value to a shell variable or array index (see Arrays), the ‘+=’ operator can be used to append to or add to the variable's previous value.</p>\n</blockquote>\n",
        "source": "so",
        "questionId": 1951506
      }
    ]
  }
]